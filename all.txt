Assignment 1 
#!/bin/sh
select=1
a=6
while [ "$select" -le "$a" ]
do
	echo "MENU\n 1)Create address book\n 2)View address book\n 3)Insert a record\n 4)Search a record\n 5)Delete a record\n 6)Modify a record\n 7)Exit\n Enter your choice:\c"
	read choice
	
	create()
	{
		touch File3.txt
		echo "RollNo\t Name\t Phone-Number\t Address\n">File3.txt

	}
	insert()
	{
	
		echo "RollNo:\c"
		read roll
		echo "Name:\c"
		read name
		echo "Phone:\c"
		while true
		do
			read phone
			len=$(echo -n $phone | wc -m)
			if test $len -eq 10 ; then
				break;
			else
				echo "\n Please enter a 10 digit number \n"
			fi
		done
		echo "Address:\c"
		read address
		echo "$roll\t $name\t $phone\t\t $address">>File3.txt #Passing values to File3
	}

	search()
	{
		echo "Enter the phone number to be searched:\c" #Searching a record by the phone number
		read phon2
		grep -q $phon2 File3.txt #Searches in File3
		if [ $? -ne 0 ]
		then
			echo "Record Not found"
		else
			grep -i -w "$phon2" File3.txt
			echo "Record found"
		fi

		
	}
	delete()
	{
		
		echo "Enter the phone number to be deleted:\c" #Deletion of records
		read phon
		grep -q -w $phon File3.txt #Searches for the entered record
		if [ $? -ne 0 ]
		then
			echo "Record Not found"
		else
			grep -v -i -w "$phon" File3.txt>File2.txt
			mv File2.txt File3.txt
			echo "Record Deleted"
		fi
	

	}

	modify()
	{
		echo "Enter the phone number to be modified:\c" #Modify the record from File3
		read phon1
		grep -q -w $phon1 File3.txt
		if [ $? -ne 0 ]
		then
			echo "Record Not found"
		else
			grep  -v -i -q -w "$phon1" File3.txt>q.txt #Passing the non selected records to q.txt
			mv q.txt File3.txt #Get all the records back to File3
			insert
		fi
	}

	case "$choice" in
	1)create;; #Creating File3
	
	
	2)cat File3.txt;;
	
	3)
		x=1
		y=1
		while [ "$x" -eq "$y" ]
		do	
			insert
			echo "Do you want to add another record \nPress 1 to continue \nPress 2 to discontinue->\c"
			read x
		done
	;;
	
	4)search;;
	
		
	5)delete;;
	
	
	6)modify;;
	
	7)exit;;
	*)echo "Invalid choice!!!";;
	esac
done






Assignment 2A
Zombie process
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<sys/wait.h>
void swap(int* arr, int i, int j) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
void bubbleSort(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1])
                swap(arr, j, j + 1);
        }
    }
}
int main(){
    int n;
    printf("Enter number of array elements: ");
    scanf("%d",&n);
    int *arr = (int *)malloc(n * sizeof(int));
    printf("Input array elements: \n");
    for (int i = 0; i < n; i++) {
        scanf("%d",&arr[i]);
    }
    pid_t pid = fork();
    if(pid==0){
        pid_t parent_id = getppid();
        pid_t child_id = getpid();
        printf("Parent id : %d \n", parent_id);
        printf("Child id: %d \n",child_id);
        bubbleSort(arr,n);
        sleep(5);
        printf("Child Array elements: ");
        for (int i = 0; i < n; i++) {
            printf("%d ",arr[i]);
        }
        printf("\n");
        exit(0);
    } else {
        bubbleSort(arr,n);
        sleep(10);
        printf("Parent Array elements: ");
        for (int i = 0; i < n; i++) {
            printf("%d ",arr[i]);
        }
        printf("\n");
        wait(NULL);
    }
    free(arr);
    return 0;
}

Output – Zombie process
meit@meit-OptiPlex-3046:~/33218/OS$ cd "/home/meit/33218/OS/" && gcc Assignment2.c -o Assignment2 && "/home/meit/33218/OS/"Assignment2
Enter number of array elements: 5  
Input array elements: 
13513 1123 355 31351 1513215
Parent id : 10122 
Child id: 10174 
Child Array elements: 355 1123 13513 31351 1513215 
Parent Array elements: 355 1123 13513 31351 1513215 
meit@meit-OptiPlex-3046:~/33218/OS$ ps aux | grep defunct
meit       10243  0.0  0.0   8908   720 pts/4    S+   12:33   0:00 grep --color=auto defunct
meit@meit-OptiPlex-3046:~/33218/OS$ ps aux | grep defunct
meit       10174  0.0  0.0      0     0 pts/1    Z+   12:33   0:00 [Assignment2] <defunct>
meit       10336  0.0  0.0   8908   720 pts/4    S+   12:33   0:00 grep --color=auto defunct
meit@meit-OptiPlex-3046:~/33218/OS$ ps aux | grep defunct
meit       10341  0.0  0.0   8908   724 pts/4    S+   12:33   0:00 grep --color=auto defunct
Orphan process
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<sys/wait.h>
void swap(int* arr, int i, int j) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
void bubbleSort(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1])
                swap(arr, j, j + 1);
        }
    }
}
int main(){
    int n;
    printf("Enter number of array elements: ");
    scanf("%d",&n);
    int *arr = (int *)malloc(n * sizeof(int));
    printf("Input array elements: \n");
    for (int i = 0; i < n; i++) {
        scanf("%d",&arr[i]);
    }
    pid_t pid = fork();
    if(pid==0){
        printf("Parent id : %d \n", getppid());
        printf("Child id: %d \n",getpid());
        bubbleSort(arr,n);
        sleep(5);
        printf("Child Array elements: ");
        for (int i = 0; i < n; i++) {
            printf("%d ",arr[i]);
        }
        printf("\nParent died \n");
        printf("Parent id : %d \n", getppid());
        printf("Child id: %d \n",getpid());
        exit(0);
    } else {
        bubbleSort(arr,n);
        sleep(3);
        printf("Parent Array elements: ");
        for (int i = 0; i < n; i++) {
            printf("%d ",arr[i]);
        }
        printf("\n");
    }
    free(arr);
    return 0;
}
Output – Orphan process
cd "/home/meit/33218/OS/" && gcc Assignment2.c -o Assignment2 && "/home/meit/33218/OS/"Assignment2
Enter number of array elements: 2
Input array elements: 
1 4
Parent id : 12497 
Child id: 12524 
Parent Array elements: 1 4 
meit@meit-OptiPlex-3046:~/33218/OS$ Child Array elements: 1 4 
Parent died 
Parent id : 1459 
Child id: 12524 
meit@meit-OptiPlex-3046:~/33218/OS$ ps -ef | grep Assignment2
meit       12497    6946  0 12:47 pts/1    00:00:00 /home/meit/33218/OS/Assignment2
meit       12524   12497  0 12:47 pts/1    00:00:00 /home/meit/33218/OS/Assignment2
meit       12532    6388  0 12:47 pts/4    00:00:00 grep --color=auto Assignment2
meit@meit-OptiPlex-3046:~/33218/OS$ ps -ef | grep Assignment2
meit       12524    1459  0 12:47 pts/1    00:00:00 /home/meit/33218/OS/Assignment2
meit       12584    6388  0 12:47 pts/4    00:00:00 grep --color=auto Assignment2
meit@meit-OptiPlex-3046:~/33218/OS$ ps -ef | grep Assignment2
meit       12648    6388  0 12:48 pts/4    00:00:00 grep --color=auto Assignment2


Assignment 2B
Assignment2B.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
void bubbleSort(int arr[], int n) {
for (int i = 0; i < n - 1; i++) {
for (int j = 0; j < n - i - 1; j++) {
if (arr[j] > arr[j + 1]) {
int temp = arr[j];
arr[j] = arr[j+1];
arr[j+1] = temp;
}
}
}
}
void printArray(const char* msg, int arr[], int n) {
printf("%s: ", msg);
for (int i = 0; i < n; i++) {
printf("%d ", arr[i]);
}
printf("\n");
}
int main() {
int n;
printf("Enter number of array elements: ");
scanf("%d", &n);
int* arr = (int*)malloc(n * sizeof(int));
if (!arr) {
perror("Memory allocation failed");
return 1;
}
printf("Enter array elements:\n");
for (int i = 0; i < n; i++) {
scanf("%d", &arr[i]);
}
bubbleSort(arr, n);
printArray("Sorted array in parent", arr, n);
char** args = (char**)malloc((n + 2) * sizeof(char*));
args[0] = "./child";
for (int i = 0; i < n; i++) {
args[i + 1] = (char*)malloc(12);
sprintf(args[i + 1], "%d", arr[i]);
}
args[n + 1] = NULL;
pid_t pid = fork();
if (pid < 0) {
perror("fork failed");
exit(1);
} else if (pid == 0) {
execve("./child", args, NULL);
perror("execve failed");
exit(1);
} else {
wait(NULL);

}
for (int i = 1; i <= n; i++) {
free(args[i]);
}
free(args);
free(arr);
return 0;
}
child.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
int main(int argc, char* argv[]) {
printf("\n--- CHILD PROCESS ---\n");
printf("Child PID: %d | Parent PID: %d\n", getpid(), getppid());
printf("Array in reverse order:\n");
for (int i = argc - 1; i >= 1; i--) {
printf("%s ", argv[i]);
}
printf("\n");
return 0;
}




Assignment 3
Shortest Job First
#include<stdio.h>
struct Process{
	int pid;
	int arrivalTime;
	int burstTime;
	int completionTime;
	int turnaroundTime;
	int waitingTime;
	int responseTime;
	int remainingTime;
};
int main(){
	struct Process processes[4];
	processes[0].pid = 100;
	processes[0].arrivalTime = 0;
	processes[0].burstTime = 7;
	processes[0].remainingTime = processes[0].burstTime;
	processes[1].pid = 200;
	processes[1].arrivalTime = 2;
	processes[1].burstTime = 4;
	processes[1].remainingTime = processes[1].burstTime;
	processes[2].pid = 300;
	processes[2].arrivalTime = 4;
	processes[2].burstTime = 1;
	processes[2].remainingTime = processes[2].burstTime;
	processes[3].pid = 400;
	processes[3].arrivalTime = 5;
	processes[3].burstTime = 4;
	processes[3].remainingTime = processes[3].burstTime;
	int totalProcesses = sizeof(processes) / sizeof(struct Process);
	int completed = 0;
	int currentTime = 0;
	while(completed < totalProcesses){
    	int idx = -1;
    	for(int i = 0; i < totalProcesses; i++){
        	if(processes[i].arrivalTime <= currentTime && processes[i].remainingTime > 0 && ( idx == -1 || processes[i].remainingTime < processes[idx].remainingTime)){
            	idx = i;
        	}}
    	if(idx != -1){
        	if(processes[idx].burstTime == processes[idx].remainingTime) processes[idx].responseTime = currentTime - processes[idx].arrivalTime;
        	processes[idx].remainingTime--;
        	currentTime++;
        	if(processes[idx].remainingTime == 0){
            	completed++;
            	processes[idx].completionTime = currentTime;
            	processes[idx].turnaroundTime = processes[idx].completionTime - processes[idx].arrivalTime;
            	processes[idx].waitingTime = processes[idx].turnaroundTime - processes[idx].burstTime;
        	}
    	}else{  
        	currentTime++;
    	}}
	printf("\n--- Process Scheduling Results (SRTF) ---\n");
	printf("+-------+-------------+-----------+----------------+---------------+-------------+--------------+\n");
	printf("| PID   | Arrival Time| Burst Time| Completion Time| Turnaround Time| Waiting Time| Response Time|\n");
	printf("+-------+-------------+-----------+----------------+---------------+-------------+--------------+\n");
	double totalWaitingTime = 0;
	double totalTurnaroundTime = 0;
	for (int i = 0; i < totalProcesses; i++) {
    	printf("| %-5d | %-11d | %-9d | %-14d | %-13d | %-11d | %-12d |\n",
           	processes[i].pid,
           	processes[i].arrivalTime,
           	processes[i].burstTime,
           	processes[i].completionTime,
           	processes[i].turnaroundTime,
           	processes[i].waitingTime,
           	processes[i].responseTime);
    	totalWaitingTime += processes[i].waitingTime;
    	totalTurnaroundTime += processes[i].turnaroundTime;
	}
	printf("+-------+-------------+-----------+----------------+---------------+-------------+--------------+\n");

	printf("\n--- Averages ---\n");
	printf("Average Waiting Time:   %.2f\n", totalWaitingTime / totalProcesses);
	printf("Average Turnaround Time: %.2f\n", totalTurnaroundTime / totalProcesses);
	return 0;
}

Round Robin Scheduling Algorithm
#include <stdio.h>
#define MAX 100
typedef struct {
	int pid;
	int at;
	int bt;
	int rt;
	int wt;
	int tat;
	int ct;
	int response_time;
	int rt_done;
	int completed;
} Process;
int main() {
	int n, time = 0, completed = 0;
	int tq;
	Process p[MAX];
	float total_wt = 0, total_tat = 0;
	printf("Enter the number of processes: ");
	scanf("%d", &n);
	for (int i = 0; i < n; i++) {
    	p[i].pid = i + 1;
    	printf("Enter Arrival Time of P%d: ", i+1);
    	scanf("%d", &p[i].at);
    	printf("Enter Burst Time of P%d: ", i+1);
    	scanf("%d", &p[i].bt);
    	p[i].rt = p[i].bt;
    	p[i].completed = 0;
    	p[i].rt_done = 0;
    	p[i].response_time = -1;
	}
	printf("Enter Time Quantum: ");
	scanf("%d", &tq);
	int queue[MAX], front = 0, rear = 0, in_queue[MAX] = {0};
	int current_time = 0;
	for (int i = 0; i < n; i++) {
    	if (p[i].at == 0) {
        	queue[rear++] = i;
        	in_queue[i] = 1;
    	}
	}
	while (completed < n) {
    	if (front == rear) {
        	int min_at = 1<<30, idx = -1;
        	for (int i = 0; i < n; i++) {
            	if (!p[i].completed && p[i].at < min_at && p[i].rt > 0) {
                	min_at = p[i].at;
                	idx = i;
            	}
        	}
        	if (idx != -1 && !in_queue[idx]) {
            	current_time = p[idx].at;
            	queue[rear++] = idx;
            	in_queue[idx] = 1;
        	} else {
            	current_time++;
        	}
        	continue;
    	}
    	int idx = queue[front++];
    	int run_time = (p[idx].rt < tq) ? p[idx].rt : tq;
    	if (!p[idx].rt_done) {
        	p[idx].response_time = current_time - p[idx].at;
        	p[idx].rt_done = 1;
    	}
    	int old_time = current_time;
    	current_time += run_time;
    	p[idx].rt -= run_time;
    	for (int i = 0; i < n; i++) {
        	if (i != idx && !in_queue[i] && p[i].at > old_time && p[i].at <= current_time && p[i].rt > 0) {
            	queue[rear++] = i;
            	in_queue[i] = 1;
        	}
    	}
    	if (p[idx].rt == 0) {
        	p[idx].completed = 1;
        	completed++;
        	p[idx].ct = current_time;
        	p[idx].tat = p[idx].ct - p[idx].at;
        	p[idx].wt = p[idx].tat - p[idx].bt;
        	total_wt += p[idx].wt;
        	total_tat += p[idx].tat;
    	} else {
        	queue[rear++] = idx;     	}
	}
	printf("P\tAT\tBT\tCT\tWT\tTAT\tRT\n");
	for (int i = 0; i < n; i++) {
    	printf("P%d\t%d\t%d\t%d\t%d\t%d\t%d\n",
        	p[i].pid, p[i].at, p[i].bt, p[i].ct, p[i].wt, p[i].tat, p[i].response_time);
	}
	printf("Average Waiting Time: %.2f\n", total_wt / n);
	printf("Average Turnaround Time: %.2f\n", total_tat / n);
	return 0;
}

Assignment 4A
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <semaphore.h>
#include <unistd.h>
#define BUFFER_SIZE 5
#define MAX_IT 20
int buffer[BUFFER_SIZE];
int in = 0;
int out = 0;
int count = 0;
sem_t empty;
sem_t full;
void* producer(void* arg) {
int item = 0;
for (int i = 0; i < MAX_IT; i++) {
//int item = rand() % 100;
sem_wait(&empty);
buffer[in] = item;
in = (in + 1) % BUFFER_SIZE;
count++;
printf("Producer produced: %d | Buffer count: %d\n", item, count);
sem_post(&full);
item++;
usleep(100000);
}
pthread_exit(NULL);
}
void* consumer(void* arg) {
for (int i = 0; i < MAX_IT; i++) {
sem_wait(&full);
int item = buffer[out];
out = (out + 1) % BUFFER_SIZE;
count--;
printf("Consumer consumed: %d | Buffer count: %d\n", item, count);
sem_post(&empty);
usleep(150000);
}
pthread_exit(NULL);

}
int main() {
pthread_t prod_thread, cons_thread;
srand(time(NULL));
sem_init(&empty, 0, BUFFER_SIZE);
sem_init(&full, 0, 0);
pthread_create(&prod_thread, NULL, producer, NULL);
pthread_create(&cons_thread, NULL, consumer, NULL);
pthread_join(prod_thread, NULL);
pthread_join(cons_thread, NULL);
printf("Production and consumption complete.\n");
return 0;
}

Assignment 4B
# include <stdio.h>
# include <pthread.h>
#include<unistd.h>
pthread_mutex_t wr,mutex;
int a=10,readcount=0;
void * reader(void * arg)
{
long int num =(long int)arg;
pthread_mutex_lock(&mutex);
readcount++;
pthread_mutex_unlock(&mutex);
if (readcount==1)
pthread_mutex_lock(&wr);
printf("\n Reader %ld is in critical section",num);
printf("\n Reader %ld reading data %d ",num,a);
sleep(1);
pthread_mutex_lock(&mutex);
readcount--;
pthread_mutex_unlock(&mutex);
if(readcount==0)
pthread_mutex_unlock(&wr);
printf("\n Reader %ld has left critical section",num);
}
void * writer(void *arg){
long int num =(long int)arg;
pthread_mutex_lock(&wr);
printf("\n Writer %ld is in critical section",num);
printf("\n Writer %ld have written data as %d ",num,++a);
sleep(1);
pthread_mutex_unlock(&wr);
printf("\n Reader %ld has left critical section",num);
}
int main(){
pthread_t r[10],w[10];
long int i,j;
int nor,now;

pthread_mutex_init(&wr,NULL);
pthread_mutex_init(&mutex,NULL);
printf("Enter the number of reader :\n");
scanf("%d",&nor);
printf("Enter the number of writer :\n");
scanf("%d",&now);
for ( i = 0; i < nor; i++)
pthread_create(&r[i],NULL,reader,(void *)i);
for (j = 0; j < now; j++)
pthread_create(&w[j],NULL,writer,(void *)j);
for ( i = 0; i < nor; i++)
{
pthread_join(r[i],NULL);
}
for ( j = 0; j < now; j++)
{
pthread_join(w[i],NULL);
}
return 0;
}


Assignment 5
#include<stdio.h>  
int main()  
{  
    // P0 , P1 , P2 , P3 , P4 are the Process names here  
    int n , m , i , j , k;  
    n = 5; // Number of processes  
    m = 3; // Number of resources  
    int alloc[ 5 ] [ 3 ] = { { 0 , 1 , 0 }, // P0 // Allocation Matrix  
                        { 2 , 0 , 0 } , // P1  
                        { 3 , 0 , 2 } , // P2  
                        { 2 , 1 , 1 } , // P3  
                        { 0 , 0 , 2 } } ; // P4  
    int max[ 5 ] [ 3 ] = { { 7 , 5 , 3 } , // P0 // MAX Matrix  
                    { 3 , 2 , 2 } , // P1  
                    { 9 , 0 , 2 } , // P2  
                    { 2 , 2 , 2 } , // P3  
                    { 4 , 3 , 3 } } ; // P4  
    int avail[3] = { 3 , 3 , 2 } ; // Available Resources  
    int f[n] , ans[n] , ind = 0 ;  
    for (k = 0; k < n; k++) {  
        f[k] = 0;  
    }  
    int need[n][m];  
    for (i = 0; i < n; i++) {  
        for (j = 0; j < m; j++)  
            need[i][j] = max[i][j] - alloc[i][j] ;  
    }  
    int y = 0;  
    for (k = 0; k < 5; k++){  
        for (i = 0; i < n; i++){  
            if (f[i] == 0){  
                int flag = 0;  
                for (j = 0; j < m; j++) {  
                    if(need[i][j] > avail[j]){  
                        flag = 1;  
                        break;  
                    }  
                }  
                if ( flag == 0 ) {  
                    ans[ind++] = i;  
                    for (y = 0; y < m; y++)  
                        avail[y] += alloc[i][y] ;  
                    f[i] = 1;  
                }  
            }  
        }  
    }  
    int flag = 1;   
    for(int i=0;i<n;i++)  
    {  
    if(f[i] == 0)  
    {  
        flag = 0;  
        printf(" The following system is not safe ");  
        break;  
    }  
    }  
    if (flag == 1)  
    {  
    printf(" Following is the SAFE Sequence \ n ");  
    for (i = 0; i < n - 1; i++)  
        printf(" P%d -> " , ans[i]);  
    printf(" P%d ", ans[n - 1]);  
    }  
    return(0);  
}  


Assignment 6
#include <stdio.h>  
/ Prototypes  
void fifo(int frameSize, int ref[], int n);  
void table(int frameSize, int refSize, int hitFlag[], int frame[] 
[refSize]);  
void LRU(int frameSize, int ref[], int n);  
void optimal(int frameSize, int ref[], int n);  
int main()  
{  
printf("\nEnter the size of the reference string: "); 
int n;  
scanf("%d", &n);  
int ref[n];  
printf("Enter the reference string: ");  
for (int i = 0; i < n; i +)  
{  
scanf("%d", &ref[i]);  
}  
printf("Enter the frame size: ");  
int frameSize;  
scanf("%d", &frameSize);  
int flag = 1;  
while (flag)  
{  
printf("\nMENU \n1 - FIFO\n2 - LRU\n3 - Optimal \n4 - 
Exit\nEnter a choice: ");  
int ch;  
scanf("%d", &ch);  
printf("\n");  
switch (ch)  
{  
case 1:  
printf("\nPage Replacement using FIFO Algorithm\n"); 
fifo(frameSize, ref, n);  
break;  
case 2:  
printf("\nPage Replacement using LRU Algorithm\n"); 
LRU(frameSize, ref, n);  
break;  
case 3:  
printf("\nPage Replacement using Optimal Algorithm\n"); 
optimal(frameSize, ref, n);  
break;  
case 4:  
flag = 0;  
printf("\nExiting .\n");  
break;  
default:  
printf("Invalid Input !!!\n\n");  
break;  
}  
}  
}  
void fifo(int frameSize, int ref[], int n)  
{  
int frame[frameSize][n];  
/ Initializing the frame to 0  
for (int i = 0; i < frameSize; i +)  
{  
for (int j = 0; j < n; j +)  
{  
frame[i][j] = 0;  
}  
}  
/ Creating a flag array and initializing to 0  
/ 0 = MISS, 1 = HIT  
int hitFlag[n];  
for (int i = 0; i < n; i +)  
{  
hitFlag[i] = 0;  
}  
/ Logic for FIFO  
int j = 0;  
for (int i = 0; i < n; i +)  
{  
int page = ref[i];  
j = j % frameSize;  
/ Checking for PAGE FAULT  
for (int k = 0; k < frameSize; k +)  
{ 
if (i > 0)  
frame[k][i] = frame[k][i - 1];  
if (page = frame[k][i])  
{  
hitFlag[i] = 1;  
break;  
}  
}  
/ if hit else miss  
if (hitFlag[i] = 0)  
{  
frame[j][i] = page;  
j +;  
}  
else  
{  
}  
}  
for (int k = 0; k < frameSize; k +)  
{  
frame[k][i] = frame[k][i - 1];  
}  
table(frameSize, n, hitFlag, frame);  
}  
void LRU(int frameSize, int ref[], int n) 
{  
int frame[frameSize][n];  
/ Initializing the frame to 0  
for (int i = 0; i < frameSize; i +)  
{  
for (int j = 0; j < n; j +)  
{  
frame[i][j] = 0;  
}  
}  
/ Creating a flag array and initializing to 0 
/ 0 = MISS, 1 = HIT  
int hitFlag[n];  
for (int i = 0; i < n; i +)  
{  
hitFlag[i] = 0;  
} 
int cnt = 0;  
for (int i = 0; i < n; i +)  
{  
int page = ref[i];  
/ Checking for PAGE FAULT  
for (int k = 0; k < frameSize; k +)  
{  
if (i > 0)  
frame[k][i] = frame[k][i - 1];  
if (page = frame[k][i])  
{  
hitFlag[i] = 1;  
break;  
}  
}  
if (hitFlag[i] = 0)  
{  
/ Miss Case  
if (cnt < frameSize)  
{  
frame[cnt][i] = page;  
cnt +;  
}  
else  
{  
int f[frameSize];  
for (int i = 0; i < frameSize; i +)  
f[i] = 0;  
*storing the indexes of the frame elements to find 
the farthest element /  
for (int k = 0; k < frameSize; k +)  
{  
int frameElement = frame[k][i];  
for (int j = i - 1; j = 0; j -)  
{  
if (ref[j] = frameElement)  
{  
}  
}  
}  
f[k] = j;  
break;  
/ Finding the farthest frame  
int miniIndex = 1e9; 
int fReplace = -1;  
for (int k = 0; k < frameSize; k +)  
{  
if (f[k] < miniIndex)  
{  
miniIndex = f[k];  
}  
}  
fReplace = k;  
/ frame replaced  
/ printf("%d-F\n",fReplace);  
frame[fReplace][i] = page;  
}  
}  
else  
{  
/ Hit Case  
for (int k = 0; k < frameSize; k +)  
{  
frame[k][i] = frame[k][i - 1];  
}  
}  
}  
/ Print the table  
table(frameSize, n, hitFlag, frame);  
}  
void optimal(int frameSize, int ref[], int n) 
{  
int frame[frameSize][n];  
/ Initializing the frame to 0  
for (int i = 0; i < frameSize; i +)  
{  
for (int j = 0; j < n; j +)  
{  
frame[i][j] = 0;  
}  
}  
/ Creating a flag array and initializing to 0 
/ 0 = MISS, 1 = HIT  
int hitFlag[n];  
for (int i = 0; i < n; i +)  
{  
hitFlag[i] = 0;  
} 
int cnt = 0;  
for (int i = 0; i < n; i +)  
{  
int page = ref[i];  
/ Checking for PAGE FAULT  
for (int k = 0; k < frameSize; k +)  
{  
if (i > 0)  
frame[k][i] = frame[k][i - 1];  
if (page = frame[k][i])  
{  
hitFlag[i] = 1;  
break;  
}  
}  
if (hitFlag[i] = 0)  
{  
/ Miss Case  
if (cnt < frameSize)  
{  
frame[cnt][i] = page;  
cnt +;  
}  
else  
{  
int f[frameSize];  
for (int i = 0; i < frameSize; i +)  
f[i] = 0;  
*storing the indexes of the frame elements to find 
the farthest element /  
for (int k = 0; k < frameSize; k +)  
{  
int frameElement = frame[k][i];  
for (int j = i + 1; j < n; j +)  
{  
if (ref[j] = frameElement)  
{  
}  
}  
}  
f[k] = j;  
break;  
/ Finding the farthest frame  
int maxIndex = -1e9; 
int fReplace = -1;  
for (int k = 0; k < frameSize; k +)  
{  
if (f[k] > maxIndex)  
{  
maxIndex = f[k];  
fReplace = k;  
}  
}  
/ frame replaced  
/ printf("%d-F\n",fReplace);  
frame[fReplace][i] = page;  
}  
}  
else  
{  
/ Hit Case  
for (int k = 0; k < frameSize; k +)  
{  
frame[k][i] = frame[k][i - 1];  
}  
}  
}  
/ Print the table  
table(frameSize, n, hitFlag, frame);  
}  
void table(int frameSize, int refSize, int hitFlag[], int frame[] 
[refSize])  
{  
int hitCnt = 0;  
int missCnt = 0;  
for (int i = 0; i < refSize; i +)  
{  
printf("-------");  
}  
printf("\n|");  
for (int i = 0; i < refSize; i +)  
{  
if (hitFlag[i])  
{  
printf(" HIT |");  
hitCnt +;  
} 
else  
{  
}  
}  
printf(" MISS |");  
missCnt +;  
printf("\n");  
for (int i = 0; i < refSize; i +)  
{  
printf("-------");  
}  
printf("\n");  
for (int j = 0; j < frameSize; j +)  
{  
printf("|");  
for (int i = 0; i < refSize; i +)  
{  
printf(" %d |", frame[j][i]);  
}  
printf("\n");  
}  
for (int i = 0; i < refSize; i +)  
{  
printf("-------");  
}  
printf("\n\n");  
printf("Hit Percent: %0.2f\n", (float)hitCnt / refSize * 100); 
printf("Miss Percent: %0.2f\n\n", (float)missCnt / refSize * 100);  
} 




Assignment 7A
Process1.cpp - Writer & Sender 
#include <iostream>  
#include <fstream>  
#include <fcntl.h>  
#include <sys/stat.h>  
#include <unistd.h>  
#include <cstring>  
 
using namespace std;  
 
#define FIFO1 "/tmp/fifo1"  
#define FIFO2 "/tmp/fifo2"  
 
int main() {  
    mkfifo(FIFO1, 0666);  
    mkfifo(FIFO2, 0666);  
 
    char buffer[1024];  
 
    cout << "Enter a sentence (type 'exit' to quit): ";  
    cin.getline(buffer, sizeof(buffer));  
 
    while (strcmp(buffer, "exit") != 0) {  
        int fd1 = open(FIFO1, O_WRONLY);  
        write(fd1, buffer, strlen(buffer) + 1);  
        close(fd1);  
 
        int fd2 = open(FIFO2, O_RDONLY);  
        read(fd2, buffer, sizeof(buffer));  
        close(fd2);  
 
        cout << "\nResult from Process2:\n" << buffer << endl;  
 
        cout << "\nEnter a sentence (type 'exit' to quit): ";  
        cin.getline(buffer, sizeof(buffer));  
    }  
 
    int fd1 = open(FIFO1, O_WRONLY);  
    write(fd1, buffer, strlen(buffer) + 1);  
    close(fd1);  
 
    return 0;  
} 
Process2.cpp - Reader & Counts Analyzer 
#include <iostream>  
#include <fstream>  
#include <fcntl.h>  
#include <sys/stat.h>  
#include <unistd.h>  
#include <cstring>  
 
using namespace std;  
 
#define FIFO1 "/tmp/fifo1"  
#define FIFO2 "/tmp/fifo2"  
 
int main() {  
    char buffer[1024];  
 
    mkfifo(FIFO1, 0666);  
    mkfifo(FIFO2, 0666);  
 
    while (true) {  
        int fd1 = open(FIFO1, O_RDONLY);  
        read(fd1, buffer, sizeof(buffer));  
        close(fd1);  
 
        if (strcmp(buffer, "exit") == 0) break;  
 
        string sentence(buffer);  
 
        int charCount = sentence.size();  
        int wordCount = 0, lineCount = 1;  
 
        bool inWord = false;  
        for (char c : sentence) {  
            if (c == ' ' || c == '\t' || c == '\n') {  
                if (inWord) {  
                    wordCount++;  
                    inWord = false;  
                }  
                if (c == '\n') lineCount++;  
            } else {  
                inWord = true;  
            }  
        }  
        if (inWord) wordCount++;  
 
        ofstream out("output.txt");  
        out << "Characters: " << charCount << endl;  
        out << "Words: " << wordCount << endl;  
        out << "Lines: " << lineCount << endl;  
        out.close();  
 
        ifstream in("output.txt");  
        string result((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());  
        in.close();  
 
        int fd2 = open(FIFO2, O_WRONLY);  
        write(fd2, result.c_str(), result.size() + 1);  
        close(fd2);  
    }  
 
    return 0;  
} 

Assignment 7B
// client.c 
#include <stdio.h> 
#include <stdlib.h> 
#include <sys/ipc.h> 
#include <sys/shm.h> 
#define SHM_SIZE 1024 // Shared memory size 
int main() { 
key_t key; 
int shmid; 
char *shm; 
// Generate the same key 
key = ftok("shmfile", 65); 
// Locate shared memory segment 
shmid = shmget(key, SHM_SIZE, 0666); 
if (shmid < 0) { 
perror("shmget"); 
exit(1); 
} 
// Attach to shared memory 
shm = (char *) shmat(shmid, NULL, 0); 
if (shm == (char *) -1) { 
perror("shmat"); 
exit(1); 
} 
// Read and display the message 
printf("Message read from shared memory: %s\n", shm); 
// Detach from shared memory 
shmdt(shm); 
// Remove shared memory 
shmctl(shmid, IPC_RMID, NULL); 
return 0; 
} 
// server.c 
#include <stdio.h> 
#include <stdlib.h> 
#include <sys/ipc.h> 
#include <sys/shm.h> 
#include <string.h> 
#define SHM_SIZE 1024 // Shared memory size 
int main() { 
key_t key; 
int shmid; 
char *shm; 
// Generate unique key 
key = ftok("shmfile", 65); 
// Create shared memory segment 
shmid = shmget(key, SHM_SIZE, 0666 | IPC_CREAT); 
if (shmid < 0) { 
perror("shmget"); 
exit(1); 
} 
// Attach to shared memory 
shm = (char *) shmat(shmid, NULL, 0); 
if (shm == (char *) -1) { 
perror("shmat"); 
exit(1); 
} 
// Take input and write into shared memory 
printf("Enter a message to write into shared memory: "); 
fgets(shm, SHM_SIZE, stdin); 
printf("Message written to shared memory.\n"); 
// Detach from shared memory 
shmdt(shm); 
return 0; 
} 
OUTPUT : 
meit@meit-OptiPlex-3046:~/Desktop/33223$ ./client 
Message read from shared memory: hello 
meit@meit-OptiPlex-3046:~/Desktop/33223$ 
meit@meit-OptiPlex-3046:~/Desktop/33223$ ./server 
Enter a message to write into shared memory: hello 
Message written to shared memory. 
meit@meit-OptiPlex-3046:~/Desktop/33223$ 

Assignment 8
#include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
 #define MAX 100
 // Function to calculate absolute difference
 int absDiff(int a, int b) {
    return abs(a - b);
 }
 // FCFS
 void FCFS(int req[], int n, int head) {
    int seek = 0;
    printf("\nFCFS Order: %d", head);
    for(int i = 0; i < n; i++) {
        seek += absDiff(head, req[i]);
        head = req[i];
        printf(" -> %d", head);
    }
    printf("\nTotal Seek Time: %d\n", seek);
 }
 // SSTF
 void SSTF(int req[], int n, int head) {
    int done[MAX] = {0}, seek = 0, count = 0;
    printf("\nSSTF Order: %d", head);
    while(count < n) {
        int min = 1e9, idx = -1;
        for(int i = 0; i < n; i++) {
            if(!done[i] && absDiff(head, req[i]) < min) {
                min = absDiff(head, req[i]);
                idx = i;
            }
        }
        done[idx] = 1;
        seek += absDiff(head, req[idx]);
        head = req[idx];
        printf(" -> %d", head);
        count++;
    }
    printf("\nTotal Seek Time: %d\n", seek);
 }
 // SCAN (Elevator)
 void SCAN(int req[], int n, int head, int disk_size, int dir) {
    int seek = 0;
    int arr[MAX];
    for(int i = 0; i < n; i++) arr[i] = req[i];
    arr[n++] = head;
    arr[n++] = (dir == 1) ? disk_size - 1 : 0;
    // sort
    for(int i = 0; i < n-1; i++)
        for(int j = i+1; j < n; j++)
            if(arr[i] > arr[j]) {
                int t = arr[i]; arr[i] = arr[j]; arr[j] = t;
            }
    int idx;
    for(idx = 0; idx < n; idx++) if(arr[idx] == head) break;
    printf("\nSCAN Order: %d", head);
    if(dir == 1) { // moving right
        for(int i = idx+1; i < n; i++) {
            seek += absDiff(head, arr[i]);
            head = arr[i];
            printf(" -> %d", head);
        }
        for(int i = idx-1; i >= 0; i--) {
            seek += absDiff(head, arr[i]);
            head = arr[i];
            printf(" -> %d", head);
        }
    } else { // moving left
        for(int i = idx-1; i >= 0; i--) {
            seek += absDiff(head, arr[i]);
            head = arr[i];
            printf(" -> %d", head);
        }
        for(int i = idx+1; i < n; i++) {
            seek += absDiff(head, arr[i]);
            head = arr[i];
            printf(" -> %d", head);
        }
    }
    printf("\nTotal Seek Time: %d\n", seek);
 }
 // C-SCAN
 void CSCAN(int req[], int n, int head, int disk_size) {
    int seek = 0;
    int arr[MAX];
    for(int i = 0; i < n; i++) arr[i] = req[i];
    arr[n++] = head;
    arr[n++] = 0;
    arr[n++] = disk_size - 1;
    // sort
    for(int i = 0; i < n-1; i++)
        for(int j = i+1; j < n; j++)
            if(arr[i] > arr[j]) {
                int t = arr[i]; arr[i] = arr[j]; arr[j] = t;
            }
    int idx;
    for(idx = 0; idx < n; idx++) if(arr[idx] == head) break;
    printf("\nC-SCAN Order: %d", head);
    for(int i = idx+1; i < n; i++) {
        seek += absDiff(head, arr[i]);
        head = arr[i];
        printf(" -> %d", head);
    }
    // jump to start
    if(head != 0) {
        seek += absDiff(head, 0);
        head = 0;
        printf(" -> %d", head);
    }
    for(int i = 0; i < idx; i++) {
        seek += absDiff(head, arr[i]);
        head = arr[i];
        printf(" -> %d", head);
    }
    printf("\nTotal Seek Time: %d\n", seek);
 }
// LOOK
 void LOOK(int req[], int n, int head, int dir) {
    int seek = 0;
    int arr[MAX];
    for(int i = 0; i < n; i++) arr[i] = req[i];
    arr[n++] = head;
    // sort
    for(int i = 0; i < n-1; i++)
        for(int j = i+1; j < n; j++)
            if(arr[i] > arr[j]) {
                int t = arr[i]; arr[i] = arr[j]; arr[j] = t;
            }
    int idx;
    for(idx = 0; idx < n; idx++) if(arr[idx] == head) break;
    printf("\nLOOK Order: %d", head);
    if(dir == 1) { // right
        for(int i = idx+1; i < n; i++) {
            seek += absDiff(head, arr[i]);
            head = arr[i];
            printf(" -> %d", head);
        }
        for(int i = idx-1; i >= 0; i--) {
            seek += absDiff(head, arr[i]);
            head = arr[i];
            printf(" -> %d", head);
        }
    } else { // left
        for(int i = idx-1; i >= 0; i--) {
            seek += absDiff(head, arr[i]);
            head = arr[i];
            printf(" -> %d", head);
        }
        for(int i = idx+1; i < n; i++) {
            seek += absDiff(head, arr[i]);
            head = arr[i];
            printf(" -> %d", head);
        }
    }
    printf("\nTotal Seek Time: %d\n", seek);
 }
 // C-LOOK
 void CLOOK(int req[], int n, int head) {
    int seek = 0;
    int arr[MAX];
    for(int i = 0; i < n; i++) arr[i] = req[i];
    arr[n++] = head;
    // sort
    for(int i = 0; i < n-1; i++)
        for(int j = i+1; j < n; j++)
            if(arr[i] > arr[j]) {
                int t = arr[i]; arr[i] = arr[j]; arr[j] = t;
            }
    int idx;
    for(idx = 0; idx < n; idx++) if(arr[idx] == head) break;
    printf("\nC-LOOK Order: %d", head);
    for(int i = idx+1; i < n; i++) {
        seek += absDiff(head, arr[i]);
        head = arr[i];
        printf(" -> %d", head);
    }
    for(int i = 0; i < idx; i++) {
        seek += absDiff(head, arr[i]);
        head = arr[i];
        printf(" -> %d", head);
    }
    printf("\nTotal Seek Time: %d\n", seek);
 }
 int main() {
    int n, head, disk_size, choice, dir;
    int req[MAX];
    printf("Enter number of requests: ");
    scanf("%d", &n);
    printf("Enter request sequence: ");
    for(int i = 0; i < n; i++) scanf("%d", &req[i]);
    printf("Enter initial head position: ");
    scanf("%d", &head);
    printf("Enter disk size: ");
    scanf("%d", &disk_size);
    do {
        printf("\n--- Disk Scheduling Menu ---\n");
        printf("1. FCFS\n2. SSTF\n3. SCAN\n4. C-SCAN\n5. LOOK\n6. C-LOOK\n7. 
Exit\n");
        printf("Enter choice: ");
        scanf("%d", &choice);
        switch(choice) {
            case 1: FCFS(req, n, head); break;
            case 2: SSTF(req, n, head); break;
            case 3: 
                printf("Enter direction (0=left, 1=right): ");
                scanf("%d", &dir);
                SCAN(req, n, head, disk_size, dir);
                break;
            case 4: CSCAN(req, n, head, disk_size); break;
            case 5: 
                printf("Enter direction (0=left, 1=right): ");
                scanf("%d", &dir);
                LOOK(req, n, head, dir);
                break;
            case 6: CLOOK(req, n, head); break;
            case 7: printf("Exiting...\n"); break;
            default: printf("Invalid choice!\n");
        }
    } while(choice != 7);
    return 0;
 }
 Output:
 pict@mplab-13:~/Documents/33222_OS/Assignment 8$ gcc assignment8.c
 pict@mplab-13:~/Documents/33222_OS/Assignment 8$ ./a.out
 Enter number of requests: 8
 Enter request sequence: 195 80 134 19 111 132 162 164
 Enter initial head position: 150
 Enter disk size: 200
--- Disk Scheduling Menu --
1. FCFS
 2. SSTF
 3. SCAN
 4. C-SCAN
 5. LOOK
 6. C-LOOK
 7. Exit
 Enter choice: 1
 FCFS Order: 150 -> 195 -> 80 -> 134 -> 19 -> 111 -> 132 -> 162 -> 164
 Total Seek Time: 474--- Disk Scheduling Menu --
1. FCFS
 2. SSTF
 3. SCAN
 4. C-SCAN
 5. LOOK
 6. C-LOOK
 7. Exit
 Enter choice: 2
 SSTF Order: 150 -> 162 -> 164 -> 134 -> 132 -> 111 -> 80 -> 19 -> 195
 Total Seek Time: 335--- Disk Scheduling Menu --
1. FCFS
 2. SSTF
 3. SCAN
 4. C-SCAN
 5. LOOK
 6. C-LOOK
 7. Exit
 Enter choice: 3
 Enter direction (0=left, 1=right): 1
 SCAN Order: 150 -> 162 -> 164 -> 195 -> 199 -> 134 -> 132 -> 111 -> 80 -> 19
 Total Seek Time: 229--- Disk Scheduling Menu --
1. FCFS
 2. SSTF
 3. SCAN
 4. C-SCAN
 5. LOOK
 6. C-LOOK
 7. Exit
 Enter choice: 4
 C-SCAN Order: 150 -> 162 -> 164 -> 195 -> 199 -> 0 -> 0 -> 19 -> 80 -> 111 -> 
132 -> 134
 Total Seek Time: 382--- Disk Scheduling Menu --
1. FCFS
 2. SSTF
 3. SCAN
 4. C-SCAN
 5. LOOK
 6. C-LOOK
 7. Exit
 Enter choice: 5
Enter direction (0=left, 1=right): 1
 LOOK Order: 150 -> 162 -> 164 -> 195 -> 134 -> 132 -> 111 -> 80 -> 19
 Total Seek Time: 221--- Disk Scheduling Menu --
1. FCFS
 2. SSTF
 3. SCAN
 4. C-SCAN
 5. LOOK
 6. C-LOOK
 7. Exit
 Enter choice: 6
 C-LOOK Order: 150 -> 162 -> 164 -> 195 -> 19 -> 80 -> 111 -> 132 -> 134
 Total Seek Time: 336
